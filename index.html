<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="ROBOTS" content="INDEX, FOLLOW" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta charset="utf-8" />

    <title>Formation React - niveau avancé</title>

    <meta name="description" content="Formation react.js niveau avancé" />
    <meta
      name="keywords"
      content="formation react, formation reactjs, hooks, useEffect, useState, freelance, patterns, best practices, es6, props, state, jsx"
    />
    <meta name="author" content="Jean-Baptite CAZAUX" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" href="reveal/reset.css" />
    <link rel="stylesheet" href="reveal/reveal.css" />
    <link rel="stylesheet" href="reveal/theme/black.css" id="theme" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="reveal/plugin/highlight/monokai.css" id="highlight-theme" />

    <style type="text/css">
      p {
        text-align: left;
      }

      .reveal h3,
      .reveal h4 {
        text-transform: none;
      }

      .reveal pre code {
        max-height: 530px;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>
            <img
              style="margin: 0"
              width="75"
              height="75"
              data-src="images/react.svg"
              src="images/react.svg"
              alt="react"
            />React.js
          </h1>
          <h6>niveau avancé</h6>
          <p style="text-align: center"><a target="_blank" href="http://twitter.com/jbcazaux">@jbcazaux</a></p>
          <p style="text-align: center">
            <a href="https://formation-reactjs.fr">https://formation-reactjs.fr</a>
          </p>
          <a href="https://www.netlify.com">
            <img
              src="https://www.netlify.com/img/global/badges/netlify-color-bg.svg"
              alt="Deploys by Netlify"
              style="border: none; background: none; box-shadow: none; margin: 0; float: right"
            />
          </a>
        </section>
        <section><img data-src="images/mynameis.jpg" alt="my name is" /></section>
        <section><img data-src="images/coffee.gif" alt="coffee break" /></section>
        <section>
          <h3>Objectifs</h3>
          <img data-src="images/postits.jpg" alt="goals" />
        </section>
        <section>
          <h3>Versions</h3>
          <pre><code data-trim>"react": "17.0.1"</code></pre>
        </section>
        <section>
          <h3>Le programme !</h3>
          <ul>
            <li>Les Hooks</li>
            <li>Optimiser</li>
            <li>Gérer les erreurs</li>
            <li>cloneElement</li>
            <li>Tester</li>
            <li>Le futur</li>
            <li>Construire son application react</li>
          </ul>
        </section>
        <section>
          <h3>Les hooks - useState</h3>
          <pre><code data-trim>
           const ComponentWithState = (props) => {
            const [count, setCount] = useState(0)
            const [user, setUser] = useState(null)
            const [color, setColor] = useState('green')

            return ...
           }
           </code></pre>
        </section>
        <section>
          <h3>Les hooks - useState</h3>
          <p>Pour mettre un état par défaut, on passe un paramètre à useState()</p>
          <pre><code data-trim>
            const [count, setCount] = useState(42)
          </code></pre>
          <p>Mettre à jour un état</p>
          <pre><code data-trim>
            const [count, setCount] = useState(0)
            setCount(10)
            setCount(prevState => prevState + 1)
            </code></pre>
          <p>Récupérer l'état courant</p>
          <pre><code data-trim>
            const [count, setCount] = useState(0)
            {count}
          </code></pre>
        </section>
        <section>
          <h3>Les hooks - useEffect</h3>
          <p>Déclenche un traitement lorsque des données (issues des props ou des states) changent</p>
          <pre><code data-trim>
            const UserDetails = ({userId}) => {
             const [details, setDetails] = useState(null)

             useEffect(() => {
              axios.get('/user/' + userId)
               .then(({response: {data: details}}) => setDetails(details))
             }, [userId])

             return ...
            }
          </code></pre>
          <p>Idée : Modifier une dépendance pour relancer l'<em>effect</em></p>
        </section>
        <section data-background="#40a0a0">
          <h3>TP hooks/useEffect</h3>
          <h4>Pour ne pas dessaler</h4>
          <ol>
            <li>Utiliser un sel comme dépendance du useEffect</li>
          </ol>
        </section>
        <section>
          <h3>Les hooks - useEffect</h3>
          <p>La méthode passée à useEffect peut retourner une <em>fonction de nettoyage</em></p>
          <pre><code data-trim>
            const UserDetails = ({userId}) => {
             const [details, setDetails] = useState(null)
             const onResize = useCallBack(event => {...}, [])

             useEffect(() => {
              window.addEventListerner('resize', onResize)
              return () => window.removeEventListener('resize', onResize)
             }, [])

             return ...
            }
          </code></pre>
        </section>
        <section>
          <h3>Les hooks - useRef</h3>
          <p>
            useRef permet de créer un objet qui aura la même référence entre 2 exécutions du composant (pas comme un
            let)
          </p>
          <p>
            Utiliser useRef pour stocker des données qui, si elles changent, ne doivent pas entrainer un réaffichage
            (réexécution) du composant
          </p>
          <pre><code data-trim>
            const Counter = () => {
             const count = useRef(0)
             return
              &lt;&gt;
                &lt;button onClick={() => count.current = count.current + 1}&gt;Click me !&lt;/button&gt;
                &lt;Super counter={count.current}/&gt;
              &lt;/&gt;
            }
          </code></pre>
        </section>
        <section data-background="#40a0a0">
          <h3>TP hooks/useRef-useEffect</h3>
          <h4>I can see dead components</h4>
          <ol>
            <li>Etudier l'erreur lors du changement de page et trouver une solution</li>
          </ol>
        </section>
        <section>
          <h3>Les hooks - useContext</h3>
          <p>
            Créer un <i>Context</i>, and et encapsuler l'application à l'intérieur du
            <i>&lt;Context.Provider&gt;</i>
          </p>
          <pre><code data-trim>
                const MyContext = React.createContext()
                export default MyContext
            </code></pre>
          <pre><code data-trim>
                ...
                return &lt;MyContext.Provider
                            value={{color: 'purple', user: new User(1, 'admin')}}&gt;
                    &lt;App/&gt;
                &lt;/MyContext.Provider&gt;
            </code></pre>
        </section>
        <section>
          <h3>Les hooks - useContext</h3>
          <p>Ensuite on récupère le <i>context</i> là où l'on veut l'utiliser avec le hook <i>useContext()</i></p>
          <pre><code data-trim>
            import React, {useContext} from 'react'
            import MyContext from './MyContext'

            const MyComponent = () => {
                const ctx = useContext(MyContext)
                return &lt;div style={{backgroundColor: ctx.color}}&gt;
                   Some text
                &lt;/div&gt;
              }
            }
            </code></pre>
        </section>
        <section data-background="#40a0a0">
          <h3>TP hooks/useContext</h3>
          <h4>Passe moi le sel !</h4>
          <ol>
            <li>Utiliser le contexte pour passer une fonction qui modifie le sel</li>
            <li>Comment améliorer ce composant Trigger ?</li>
          </ol>
        </section>
        <section>
          <h3>Les hooks - useMemo</h3>
          <p>
            useMemo permet de <em>memoize</em> une fonction, c'est à dire de mettre en mémoire son résultat afin de le
            retourner lors d'un futur appel avec les mêmes paramètres.
          </p>
          <pre><code data-trim>
            const Calculator = ({a, b}) => {
             const result = useMemo(() => a + b, [a, b])
             return &lt;div&gt; {result} &lt;/div&gt;
            }
          </code></pre>
        </section>
        <section data-background="#40a0a0">
          <h3>TP hooks/useMemo</h3>
          <h4>Souviens toi le résultat dernier</h4>
          <ol>
            <li>Vérifier que la méthode passée à useMemo n'est pas appelée plusieurs fois</li>
          </ol>
        </section>
        <section data-auto-animate data-visibility="hidden">
          <h3 data-id="memo">Perfs - React.memo</h3>
          <p data-id="memo-p">React.memo permet de <em>memoize</em> un composant React.</p>
          <pre data-id="memo-pre"><code data-trim>
           const MyComponent = () => ...
           export default React.memo(MyComponent)
          </code></pre>
        </section>
        <section data-auto-animate>
          <h3 data-id="memo">Perfs - React.memo</h3>
          <p data-id="memo-p">React.memo permet de <em>memoize</em> un composant React.</p>
          <pre data-id="memo-pre"><code data-trim>
           const MyComponent = () => ...
           export default React.memo(MyComponent, (prevProps, nextProps) => {
            return prevProps.user?.id === nextProps.user?.id
           })
          </code></pre>
        </section>
        <section>
          <h3>Perfs - useCallback</h3>
          <p>
            useCallback permet de ne pas recréer une nouvelle fonction à chaque exécution (re-render) d'un composant.
            Ces fonctions sont destinées à être passées comme callback aux composants enfants.
          </p>
          <pre><code data-trim>
           const MyComponent = () => {
            const handleClick = useCallback(e => console.log(e))

            return &lt;button onclick={handleClick}&gt;Click me&lt;/&gt;
           })
          </code></pre>
        </section>
        <section data-background="#40a0a0">
          <h3>TP perfs/memo</h3>
          <h4>Souviens toi le composant dernier</h4>
          <ol>
            <li>Utiliser React dev tools pour montrer que le composant <em>Button</em> est réaffiché plusieurs fois</li>
            <li>Utiliser React.memo</li>
          </ol>
        </section>
        <section>
          <h3>Perfs - code splitting / lazy loading</h3>
          <p>
            Charger une partie des sources à la demande.
          </p>
          <pre><code data-trim>
           const LazyComponent = React.lazy(() =>
            import(/* webpackChunkName: "nomDuBundle" */ './Goodbye')
           )
           const MyComponent = () => (
            &lt;Suspense fallback={&lt;div&gt;Loading... !&lt;/div&gt;}>
              &lt;LazyComponent/&gt;
            &lt;/Suspense&gt;
           )
          </code></pre>
          <p style="font-size: .6em">
            Options webpack : <i>webpackPrefetch</i>, <i>webpackPreload</i>
          </p>
        </section>
        <section>
          <h3>Perfs - code splitting / lazy loading</h3>
          <p>
            Attendre que les sous-composants soient entièrement chargés, et afficher un autre composant en attendant
          </p>
          <pre><code data-trim>
           const LazyComponent = React.lazy(() =>
            import(/* webpackChunkName: "nomDuBundle" */ './Goodbye')
           )
           const MyComponent = () => (
            &lt;Suspense fallback={&lt;div&gt;Loading... !&lt;/div&gt;}>
              &lt;LazyComponent/&gt;
            &lt;/Suspense&gt;
           )
          </code></pre>
          <p style="font-size: .6em">
            Options webpack : <i>webpackPrefetch</i>, <i>webpackPreload</i>
          </p>
        </section>
        <section data-background="#40a0a0">
          <h3>TP perfs/lazy-suspense</h3>
          <h4>Feignant !</h4>
          <ol>
            <li>Utiliser React.lazy et les imports dynamiques pour différer le chargement du composant GoodBye</li>
          </ol>
        </section>
        <section>
          <h3>Gestion des erreurs inatendues</h3>
          <p>
            Eviter que l'application ne crashe totalement avec les ErrorBoundaries.
          </p>
          <pre><code data-trim>
          class ErrorBoundary extends React.Component {
            constructor(props) {
              super(props)
              this.state = {error : null}
            }
            static getDerivedStateFromError(error) {
              // appelé en cas d'erreur,
              // Peut retourner un nouvel état
            }
            componentDidCatch(error, errorInfo) {
              // appelé en cas d'erreur
            }
            render() {
              return this.props.children
            }
          }
          </code></pre>
        </section>
        <section data-background="#40a0a0">
          <h3>TP ErrorBoundary</h3>
          <h4>Rattraper ses erreurs</h4>
          <ol>
            <li>Modifier ErrorBoudary pour qu'il affiche ses sous-composants (children)</li>
            <li>L'application crashe si on clique sur une ville qui commence par un A (faire le test !)</li>
            <li>Mettre à jour le state pour que le composant se redessine en se basant sur ce nouvel état</li>
            <li>Modifier la méthode render pour afficher un message en cas d'erreur</li>
            <li>Bonus : pourquoi l'appli continue à afficher le message d'erreur après un clic sur une autre ville ? Comment le corriger ?</li>
          </ol>
        </section>
      </div>

      <script src="reveal/reveal.js"></script>
      <script src="reveal/plugin/zoom/zoom.js"></script>
      <script src="reveal/plugin/notes/notes.js"></script>
      <script src="reveal/plugin/search/search.js"></script>
      <script src="reveal/plugin/markdown/markdown.js"></script>
      <script src="reveal/plugin/highlight/highlight.js"></script>
      <script>
        Reveal.initialize({
          controls: true,
          progress: true,
          center: true,
          hash: true,
          showHiddenSlides: true,

          plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight],
        })
      </script>
    </div>
  </body>
</html>
